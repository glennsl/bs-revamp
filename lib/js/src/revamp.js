// Generated by BUCKLESCRIPT VERSION 1.8.3, PLEASE EDIT WITH CARE
'use strict';

var List                    = require("bs-platform/lib/js/list.js");
var Sequence                = require("./sequence.js");
var Caml_array              = require("bs-platform/lib/js/caml_array.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function _flagToString(param) {
  switch (param) {
    case 0 : 
        return "i";
    case 1 : 
        return "m";
    case 2 : 
        return "u";
    
  }
}

function _assertValid(re) {
  if (re.lastIndex !== 0) {
    var lastIndex = re.lastIndex;
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Invalid RegEx, lastIndex should be 0, is " + (String(lastIndex) + " (This should never happen, file a bug!)")
        ];
  }
  if (+re.global !== /* true */1) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Invalid RegEx, global == false (This should never happen, file a bug!)"
        ];
  } else {
    return 0;
  }
}

function _reset(re) {
  re.lastIndex = 0;
  return /* () */0;
}

function compile($staropt$star, pattern) {
  var flags = $staropt$star ? $staropt$star[0] : /* [] */0;
  var flags$1 = List.fold_left((function (acc, flag) {
          return acc + flag;
        }), "g", List.map(_flagToString, flags));
  return new RegExp(pattern, flags$1);
}

function exec(input, re) {
  _assertValid(re);
  var next = function (start, _) {
    re.lastIndex = start;
    var match = re.exec(input);
    if (match !== null) {
      var nextIndex = re.lastIndex;
      re.lastIndex = 0;
      return /* Cons */[
              match,
              (function (param) {
                  return next(nextIndex, param);
                })
            ];
    } else {
      return /* Nil */0;
    }
  };
  return (function (param) {
      return next(0, param);
    });
}

function matches(input, re) {
  return Sequence.map((function (result) {
                return result[0];
              }), exec(input, re));
}

function indices(input, re) {
  return Sequence.map((function (prim) {
                return prim.index;
              }), exec(input, re));
}

function captures(input, re) {
  return Sequence.map((function (result) {
                return result.slice(1);
              }), exec(input, re));
}

function test(input, re) {
  _assertValid(re);
  var res = +re.test(input);
  re.lastIndex = 0;
  return res;
}

function find(input, re) {
  _assertValid(re);
  var match = re.exec(input);
  if (match !== null) {
    re.lastIndex = 0;
    var index = match.index;
    return /* Some */[/* tuple */[
              Caml_array.caml_array_get(match, 0),
              index,
              match
            ]];
  } else {
    return /* None */0;
  }
}

function count(input, re) {
  return Sequence.count(exec(input, re));
}

exports._flagToString = _flagToString;
exports._assertValid  = _assertValid;
exports._reset        = _reset;
exports.compile       = compile;
exports.exec          = exec;
exports.matches       = matches;
exports.indices       = indices;
exports.captures      = captures;
exports.test          = test;
exports.find          = find;
exports.count         = count;
/* No side effect */
