// Generated by BUCKLESCRIPT VERSION 1.8.3, PLEASE EDIT WITH CARE
'use strict';

var List                    = require("bs-platform/lib/js/list.js");
var Curry                   = require("bs-platform/lib/js/curry.js");
var Caml_array              = require("bs-platform/lib/js/caml_array.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function _flagToString(param) {
  switch (param) {
    case 0 : 
        return "i";
    case 1 : 
        return "m";
    case 2 : 
        return "u";
    
  }
}

function _assertValid(re) {
  if (re.lastIndex !== 0) {
    var lastIndex = re.lastIndex;
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Invalid RegEx, lastIndex should be 0, is " + (String(lastIndex) + " (This should never happen, file a bug!)")
        ];
  }
  if (+re.global !== /* true */1) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Invalid RegEx, global == false (This should never happen, file a bug!)"
        ];
  } else {
    return 0;
  }
}

function _reset(re) {
  re.lastIndex = 0;
  return /* () */0;
}

function compile($staropt$star, pattern) {
  var flags = $staropt$star ? $staropt$star[0] : /* [] */0;
  var flags$1 = List.fold_left((function (acc, flag) {
          return acc + flag;
        }), "g", List.map(_flagToString, flags));
  return new RegExp(pattern, flags$1);
}

function forEach(f, input, re) {
  _assertValid(re);
  var _param = /* () */0;
  while(true) {
    var match = re.exec(input);
    if (match !== null) {
      var index = match.index;
      Curry._3(f, Caml_array.caml_array_get(match, 0), index, match);
      _param = /* () */0;
      continue ;
      
    } else {
      return /* () */0;
    }
  };
}

function test(input, re) {
  _assertValid(re);
  var res = +re.test(input);
  re.lastIndex = 0;
  return res;
}

function count(input, re) {
  _assertValid(re);
  var n = [0];
  forEach((function (_, _$1, _$2) {
          n[0] = n[0] + 1 | 0;
          return /* () */0;
        }), input, re);
  return n[0];
}

function find(input, re) {
  _assertValid(re);
  var match = re.exec(input);
  if (match !== null) {
    re.lastIndex = 0;
    var index = match.index;
    return /* Some */[/* tuple */[
              Caml_array.caml_array_get(match, 0),
              index,
              match
            ]];
  } else {
    return /* None */0;
  }
}

exports._flagToString = _flagToString;
exports._assertValid  = _assertValid;
exports._reset        = _reset;
exports.compile       = compile;
exports.forEach       = forEach;
exports.test          = test;
exports.count         = count;
exports.find          = find;
/* No side effect */
