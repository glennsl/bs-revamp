// Generated by BUCKLESCRIPT VERSION 1.8.3, PLEASE EDIT WITH CARE
'use strict';

var List                    = require("bs-platform/lib/js/list.js");
var Sequence                = require("./sequence.js");
var Caml_array              = require("bs-platform/lib/js/caml_array.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function _flagToString(param) {
  switch (param) {
    case 0 : 
        return "i";
    case 1 : 
        return "m";
    case 2 : 
        return "u";
    
  }
}

function _assertValid(re) {
  if (re.lastIndex !== 0) {
    var lastIndex = re.lastIndex;
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Invalid RegEx, lastIndex should be 0, is " + (String(lastIndex) + " (This should never happen, file a bug!)")
        ];
  }
  if (+re.global !== /* true */1) {
    throw [
          Caml_builtin_exceptions.invalid_argument,
          "Invalid RegEx, global == false (This should never happen, file a bug!)"
        ];
  } else {
    return 0;
  }
}

function _reset(re) {
  re.lastIndex = 0;
  return /* () */0;
}

function make($staropt$star, pattern) {
  var flags = $staropt$star ? $staropt$star[0] : /* [] */0;
  var flags$1 = List.fold_left((function (acc, flag) {
          return acc + flag;
        }), "g", List.map(_flagToString, flags));
  return new RegExp(pattern, flags$1);
}

function exec(re, input) {
  _assertValid(re);
  var next = function (start, _) {
    re.lastIndex = start;
    var match = re.exec(input);
    if (match !== null) {
      var nextIndex = re.lastIndex;
      re.lastIndex = 0;
      return /* Cons */[
              match,
              (function (param) {
                  return next(nextIndex, param);
                })
            ];
    } else {
      return /* Nil */0;
    }
  };
  return (function (param) {
      return next(0, param);
    });
}

function matches(re, input) {
  return Sequence.map((function (result) {
                return result[0];
              }), exec(re, input));
}

function indices(re, input) {
  return Sequence.map((function (result) {
                var index = result.index;
                var match_ = result[0];
                return /* tuple */[
                        index,
                        index + match_.length | 0
                      ];
              }), exec(re, input));
}

function captures(re, input) {
  return Sequence.map((function (result) {
                return result.slice(1);
              }), exec(re, input));
}

function test(re, input) {
  _assertValid(re);
  var res = +re.test(input);
  re.lastIndex = 0;
  return res;
}

function find(re, input) {
  _assertValid(re);
  var match = re.exec(input);
  if (match !== null) {
    re.lastIndex = 0;
    return /* Some */[Caml_array.caml_array_get(match, 0)];
  } else {
    return /* None */0;
  }
}

function findIndex(re, input) {
  _assertValid(re);
  var match = re.exec(input);
  if (match !== null) {
    re.lastIndex = 0;
    var index = match.index;
    return /* Some */[/* tuple */[
              index,
              index + Caml_array.caml_array_get(match, 0).length | 0
            ]];
  } else {
    return /* None */0;
  }
}

function count(re, input) {
  return Sequence.count(exec(re, input));
}

function replace(re, f, input) {
  return input.replace(re, f);
}

function split(re, input) {
  return input.split(re);
}

var Compiled = /* module */[
  /* make */make,
  /* exec */exec,
  /* matches */matches,
  /* indices */indices,
  /* captures */captures,
  /* test */test,
  /* find */find,
  /* findIndex */findIndex,
  /* count */count,
  /* replace */replace,
  /* split */split
];

function exec$1(pattern, $staropt$star, input) {
  var flags = $staropt$star ? $staropt$star[0] : /* [] */0;
  return exec(make(/* Some */[flags], pattern), input);
}

function matches$1(pattern, $staropt$star, input) {
  var flags = $staropt$star ? $staropt$star[0] : /* [] */0;
  return matches(make(/* Some */[flags], pattern), input);
}

function indices$1(pattern, $staropt$star, input) {
  var flags = $staropt$star ? $staropt$star[0] : /* [] */0;
  return indices(make(/* Some */[flags], pattern), input);
}

function captures$1(pattern, $staropt$star, input) {
  var flags = $staropt$star ? $staropt$star[0] : /* [] */0;
  return captures(make(/* Some */[flags], pattern), input);
}

function test$1(pattern, $staropt$star, input) {
  var flags = $staropt$star ? $staropt$star[0] : /* [] */0;
  return test(make(/* Some */[flags], pattern), input);
}

function find$1(pattern, $staropt$star, input) {
  var flags = $staropt$star ? $staropt$star[0] : /* [] */0;
  return find(make(/* Some */[flags], pattern), input);
}

function findIndex$1(pattern, $staropt$star, input) {
  var flags = $staropt$star ? $staropt$star[0] : /* [] */0;
  return findIndex(make(/* Some */[flags], pattern), input);
}

function count$1(pattern, $staropt$star, input) {
  var flags = $staropt$star ? $staropt$star[0] : /* [] */0;
  var re = make(/* Some */[flags], pattern);
  return Sequence.count(exec(re, input));
}

function replace$1(pattern, $staropt$star, f, input) {
  var flags = $staropt$star ? $staropt$star[0] : /* [] */0;
  return input.replace(make(/* Some */[flags], pattern), f);
}

function split$1(pattern, $staropt$star, input) {
  var flags = $staropt$star ? $staropt$star[0] : /* [] */0;
  return input.split(make(/* Some */[flags], pattern));
}

exports._flagToString = _flagToString;
exports._assertValid  = _assertValid;
exports._reset        = _reset;
exports.Compiled      = Compiled;
exports.exec          = exec$1;
exports.matches       = matches$1;
exports.indices       = indices$1;
exports.captures      = captures$1;
exports.test          = test$1;
exports.find          = find$1;
exports.findIndex     = findIndex$1;
exports.count         = count$1;
exports.replace       = replace$1;
exports.split         = split$1;
/* No side effect */
