// Generated by BUCKLESCRIPT VERSION 1.8.3, PLEASE EDIT WITH CARE
'use strict';

var Jest     = require("bs-jest/lib/js/src/jest.js");
var Revamp   = require("../src/revamp.js");
var Sequence = require("../src/sequence.js");

var pattern = "(an)+([^d])";

describe("compile", (function () {
        return /* () */0;
      }));

describe("matches", (function () {
        var run = function (input) {
          return Sequence.toList((function (eta) {
                          return Revamp.matches(pattern, /* None */0, eta);
                        })(input));
        };
        Jest.test("match", (function () {
                return Jest.Expect[/* toEqual */11](/* :: */[
                              "ang",
                              /* :: */[
                                "anana",
                                /* [] */0
                              ]
                            ])(Jest.Expect[/* expect */0](run("mangos and bananas")));
              }));
        return Jest.test("no match", (function () {
                      return Jest.Expect[/* toEqual */11](/* [] */0)(Jest.Expect[/* expect */0](run("apples and pears")));
                    }));
      }));

describe("indices", (function () {
        var run = function (input) {
          return Sequence.toList((function (eta) {
                          return Revamp.indices(pattern, /* None */0, eta);
                        })(input));
        };
        Jest.test("match", (function () {
                return Jest.Expect[/* toEqual */11](/* :: */[
                              /* tuple */[
                                1,
                                4
                              ],
                              /* :: */[
                                /* tuple */[
                                  12,
                                  17
                                ],
                                /* [] */0
                              ]
                            ])(Jest.Expect[/* expect */0](run("mangos and bananas")));
              }));
        return Jest.test("no match", (function () {
                      return Jest.Expect[/* toEqual */11](/* [] */0)(Jest.Expect[/* expect */0](run("apples and pears")));
                    }));
      }));

describe("captures", (function () {
        var run = function (input) {
          return Sequence.toList((function (eta) {
                          return Revamp.captures(pattern, /* None */0, eta);
                        })(input));
        };
        Jest.test("match", (function () {
                return Jest.Expect[/* toEqual */11](/* :: */[
                              /* array */[
                                "an",
                                "g"
                              ],
                              /* :: */[
                                /* array */[
                                  "an",
                                  "a"
                                ],
                                /* [] */0
                              ]
                            ])(Jest.Expect[/* expect */0](run("mangos and bananas")));
              }));
        return Jest.test("no match", (function () {
                      return Jest.Expect[/* toEqual */11](/* [] */0)(Jest.Expect[/* expect */0](run("apples and pears")));
                    }));
      }));

describe("test", (function () {
        Jest.test("match", (function () {
                return Jest.Expect[/* toBe */1](/* true */1)(Jest.Expect[/* expect */0](Revamp.test(pattern, /* None */0, "mangos and bananas")));
              }));
        return Jest.test("no match", (function () {
                      return Jest.Expect[/* toBe */1](/* false */0)(Jest.Expect[/* expect */0](Revamp.test(pattern, /* None */0, "apples and pears")));
                    }));
      }));

describe("count", (function () {
        Jest.test("match", (function () {
                return Jest.Expect[/* toBe */1](2)(Jest.Expect[/* expect */0](Revamp.count(pattern, /* None */0, "mangos and bananas")));
              }));
        return Jest.test("no match", (function () {
                      return Jest.Expect[/* toBe */1](0)(Jest.Expect[/* expect */0](Revamp.count(pattern, /* None */0, "apples and pears")));
                    }));
      }));

describe("find", (function () {
        Jest.test("match", (function () {
                return Jest.Expect[/* toEqual */11](/* Some */["ang"])(Jest.Expect[/* expect */0](Revamp.find(pattern, /* None */0, "mangos and bananas")));
              }));
        return Jest.test("no match", (function () {
                      return Jest.Expect[/* toBe */1](/* None */0)(Jest.Expect[/* expect */0](Revamp.find(pattern, /* None */0, "apples and pears")));
                    }));
      }));

describe("findIndex", (function () {
        Jest.test("match", (function () {
                return Jest.Expect[/* toEqual */11](/* Some */[/* tuple */[
                                1,
                                4
                              ]])(Jest.Expect[/* expect */0](Revamp.findIndex(pattern, /* None */0, "mangos and bananas")));
              }));
        return Jest.test("no match", (function () {
                      return Jest.Expect[/* toBe */1](/* None */0)(Jest.Expect[/* expect */0](Revamp.findIndex(pattern, /* None */0, "apples and pears")));
                    }));
      }));

describe("replace", (function () {
        Jest.test("match", (function () {
                return Jest.Expect[/* toEqual */11]("mfooos and bfoos")(Jest.Expect[/* expect */0](Revamp.replace(pattern, /* None */0, (function () {
                                      return "foo";
                                    }), "mangos and bananas")));
              }));
        Jest.test("no match", (function () {
                return Jest.Expect[/* toEqual */11]("apples and pears")(Jest.Expect[/* expect */0](Revamp.replace(pattern, /* None */0, (function () {
                                      return "foo";
                                    }), "apples and pears")));
              }));
        return Jest.test("capture", (function () {
                      return Jest.Expect[/* toEqual */11]("mfooos and bfoos")(Jest.Expect[/* expect */0](Revamp.replace(pattern, /* None */0, (function () {
                                            return "[$1]";
                                          }), "mangos and bananas")));
                    }));
      }));

describe("split", (function () {
        Jest.test("match", (function () {
                return Jest.Expect[/* toEqual */11](/* array */[
                              "bang",
                              "bang",
                              "bananabatman",
                              ""
                            ])(Jest.Expect[/* expect */0](Revamp.split(" |!", /* None */0, "bang bang bananabatman!")));
              }));
        return Jest.test("no match", (function () {
                      return Jest.Expect[/* toEqual */11](/* array */["apples"])(Jest.Expect[/* expect */0](Revamp.split(" |!", /* None */0, "apples")));
                    }));
      }));

exports.pattern = pattern;
/*  Not a pure module */
